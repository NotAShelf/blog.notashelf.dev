<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link
      rel="apple-touch-icon"
      sizes="57x57"
      href="/assets/apple-icon-57x57.png"
    />
    <link
      rel="apple-touch-icon"
      sizes="60x60"
      href="/assets/apple-icon-60x60.png"
    />
    <link
      rel="apple-touch-icon"
      sizes="72x72"
      href="/assets/apple-icon-72x72.png"
    />
    <link
      rel="apple-touch-icon"
      sizes="76x76"
      href="/assets/apple-icon-76x76.png"
    />
    <link
      rel="apple-touch-icon"
      sizes="114x114"
      href="/assets/apple-icon-114x114.png"
    />
    <link
      rel="apple-touch-icon"
      sizes="120x120"
      href="/assets/apple-icon-120x120.png"
    />
    <link
      rel="apple-touch-icon"
      sizes="144x144"
      href="/assets/apple-icon-144x144.png"
    />
    <link
      rel="apple-touch-icon"
      sizes="152x152"
      href="/assets/apple-icon-152x152.png"
    />
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="/assets/apple-icon-180x180.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="192x192"
      href="/assets/android-icon-192x192.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="/assets/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="96x96"
      href="/assets/favicon-96x96.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="/assets/favicon-16x16.png"
    />
    <link rel="manifest" href="/manifest.json" />
    <meta name="msapplication-TileColor" content="#ffffff" />
    <meta name="msapplication-TileImage" content="/ms-icon-144x144.png" />
    <meta name="theme-color" content="#ffffff" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
         <meta name="dcterms.date" content="2025-04-03" />
          <meta name="description" content="From Javascript, to Golang and Rust" />
        <title>My New Tech Stack</title>
    <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      div.columns{display: flex; gap: min(4vw, 1.5em);}
      div.column{flex: auto; overflow-x: auto;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      /* The extra [class] is a hack that increases specificity enough to
         override a similar rule in reveal.js */
      ul.task-list[class]{list-style: none;}
      ul.task-list li input[type="checkbox"] {
        font-size: inherit;
        width: 0.8em;
        margin: 0 0.8em 0.2em -1.6em;
        vertical-align: middle;
      }
      .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    </style>
        <link rel="stylesheet" href="/style.css" />
        <!-- Begin Lineicons import -->
    <link rel="stylesheet" href="https://cdn.lineicons.com/5.0/lineicons.css" />
    <!-- End Lineicons import-->
    <link rel="stylesheet" href="/style.css" />
    <link
      rel="shortcut icon"
      href="/assets/favicon-96x96.png"
      type="image/x-icon"
    />
  </head>
  <body>
    <header class="page-navigation">
      <nav class="primary-buttons">
        <ul>
          <li><a class="nav-button" href="/">Index</a></li>
        </ul>
      </nav>
      <nav class="secondary-buttons">
        <ul>
          <li>
            <a class="nav-button" href="/posts"> Posts </a>
            <a class="nav-button" href="/about.html"> About </a>
            <a class="nav-button" href="/privacy.html"> Privacy </a>
          </li>
        </ul>
      </nav>
    </header>
    <hr class="nav-border">

    <main>
      <!-- Keywords, if any. -->
      

      <!-- Table of Contents, if enabled -->
       <h1
id="from-golang-to-rust-with-a-dash-of-c-and-a-look-at-zig-a-technical-journey">From
Golang to Rust (with a Dash of C and a Look at Zig): A Technical
Journey</h1>
<div class="reading-time">
<p>8 minute read</p>
</div>
<p>I have began programming with Javascript back in 2018. It was a
spontaneous decision, made mostly in the hope of solving a basic problem
that a game server that I moderated was facing. Long story short, I
learned Javascript (or at least, some Javascript) over night and that
was it for a while.</p>
<p>That somehow propelled me head-first into web development. I was
young, I wanted a personal website and maybe I could even make a few
bucks on the side from developing websites for people. Since I knew
Javascript somewhat decently, I began looking at HTML and CSS, read some
web blogs and a few programming books that describe the basics of web
development and went on with my journey.</p>
<p>Alongside other experiences, this lead me to use Linux as my main
operating system and one of the most important reasons why I chose Linux
was because it was a liberating, customizable experience. As I moved to
use tiling window managers (i3 at the time), I also began experimenting
with writing my own desktop utilities. Learn Python, Go, C, little bit
of C++ and eventually Rust; which is now most of my stack.</p>
<p>While my programming journey has taken a winding road through
multiple languages, each offering a unique set of strengths and
trade-offs. Recently, I made the decision to transition from Golang to
Rust while still retaining C in my toolbox. This post details the
technical reasoning behind this move, the advantages of each language,
and why, despite its venerable status, C‚Äôs build tooling still leaves
much to be desired.</p>
<h2 id="the-golang-chapter" id="the-golang-chapter">The Golang
Chapter <a href="#the-golang-chapter" class="anchor-link">üîó</a></h2>
<p>Go was‚Ä¶ a compelling choice to say the least. Be it for its
simplicity, powerful cocurrency model and rapid compilation times (which
I miss to this day in Rust.) Its robust standard library and clean
syntax allowed me to build distributed systems with ease. However, as
projects grew in complexity, several limitations became apparent.</p>
<p>One very large issue was memory management. I want my software to be
<em>lean and mean</em> but Go‚Äôs garbage collection was imposing
unpredictable latencies‚Äîan issue in performance-sensitive applications
that are the backbone of my home network. For example, in a real-time
data processing application, garbage collection pauses caused noticeable
delays. Benchmarks like <code>goperf</code> have shown that garbage
collection pauses can sometimes exceed acceptable limits, making Go much
less suitable for low-latency requirements. The type system is also,
despite its simplicity, a hit-or-miss and it can can feel limiting when
dealing with more intricate, low-level abstractions or when requiring
fine-grained control over data. Lastly, the overhead introduced by some
of Go‚Äôs abstractions are a bottleneck that I‚Äôve grown a distaste for
during my time using Nix.</p>
<p>These aspects led me to explore alternatives that offer more control
without sacrificing safety or performance.</p>
<h2 id="why-rust" id="why-rust">Why
Rust? <a href="#why-rust" class="anchor-link">üîó</a></h2>
<p>I didn‚Äôt switch to Rust because of hype. If anything, the constant
evangelism around ‚Äúmemory safety‚Äù as if it‚Äôs the only thing that matters
was a turnoff. But Rust kept solving real problems I hit when working in
Go and C, to the point where using anything else felt like unnecessary
friction. It emerged as a <em>natural next step</em>. It is widely used,
and even more widely shilled. While I was using Go, I had experimented
with Rust several times but extremely long build times‚Äîalongside the
complex type system‚Äîdrove me off each time. Eventually I accepted those
as a cost for correctness, and began migrating to Rust. Although, it was
a slow process. The Rust book was extremely unhelpful, especially in the
pacing department, but eventually and through the help of many web
searches I accepted Rust. It brings several improvements that address
the limitations I experienced with Golang, which I would like to go
over.</p>
<h3 id="1-memory-safety-without-performance-penalties"
id="1-memory-safety-without-performance-penalties">1. Memory Safety
without Performance
Penalties <a href="#1-memory-safety-without-performance-penalties" class="anchor-link">üîó</a></h3>
<p>First advantage I‚Äôm quite fond of is Rust‚Äôs <strong>memory safety
without the need for a garbage collector</strong>. Rust‚Äôs ownership
model ensures memory safety at compile time without relying on a garbage
collector. This allows for predictable performance, a very crucial
factor that affected my decision The borrow checker, while initially
imposing a learning curve, provides a safety net that prevents data
races and dangling pointers. Unlike Go, where garbage collection kicks
in unpredictably, Rust‚Äôs compile-time borrow checker also ensures that
memory is allocated and freed at the right time. Unlike C, which is
another language I enjoy writing, but not so much *using, it doesn‚Äôt
require explicit <code>malloc</code>/<code>free</code> calls or
reference counting in most cases, meaning it balances control and
automation far better than either language.</p>
<p>Instead of garbage collection, Rust relies on <strong>RAII</strong>
(Resource Acquisition Is Initialization), where memory is freed as soon
as it goes out of scope. Consequently the borrow checker ensures safe
aliasing of memory, use-after-free bugs, and iterator invalidation.
Nice. I want to control my memory, without having to micromanange
it.</p>
<h3 id="2-true-zero-cost-abstractions"
id="2-true-zero-cost-abstractions">2. <em>True</em> Zero-Cost
Abstractions <a href="#2-true-zero-cost-abstractions" class="anchor-link">üîó</a></h3>
<p>Golang‚Äôs philosophy is ‚Äúsimple is better.‚Äù The problem is that
simplicity in Go often means ‚Äúdumbed down.‚Äù No proper generics (until
recently), no inlining across package boundaries, and everything is done
through interfaces that introduce runtime overhead. As such, a common
issue I had with Go is that writing high-level, ergonomic code often
meant sacrificing performance. Interfaces, reflection, and even some
seemingly simple abstractions introduce overhead that isn‚Äôt always
obvious (or sometimes not even available because‚Ä¶ I don‚Äôt know.) Rust
does <em>not</em> have this problem because of its zero-cost abstraction
principle: abstractions should compile down to the most efficient
possible machine code.</p>
<p>For example, iterators in Rust provide the same expressiveness as
Go‚Äôs slices but compile into raw loops without runtime overhead.
Generics in Rust are fully monomorphized at compile time, meaning
there‚Äôs no boxing or interface dispatch cost. This means Rust allows
writing expressive, high-level code while maintaining (mostly) C-level
performance. I have learned recently that Rust compiles down to
efficient machine code thanks to <strong>monomorphization</strong> (try
saying that out loud 3 times in a row)‚Äîa process where generics are
fully expanded at compile time, allowing optimizations that eliminate
runtime dispatch overhead. Combined with LLVM‚Äôs optimizations, Rust
often generates assembly that is as fast as, or faster than, handwritten
C.</p>
<h3 id="3-concurrency-without-race-conditions"
id="3-concurrency-without-race-conditions">3. Concurrency Without Race
Conditions <a href="#3-concurrency-without-race-conditions" class="anchor-link">üîó</a></h3>
<p>Goroutines and channels are nice, but they don‚Äôt prevent data races.
In Go, you still need to rely on locks, atomics, etc, and most
importantly careful design to avoid issues like race conditions or
deadlocks. Rust enforces safety at the type level. This means that Rust
code, once compiled, has <em>mathematically guaranteed</em> thread
safety. No surprises, no debugging obscure race conditions in
production. The <code>Send</code> and <code>Sync</code> traits act as
static checks that prevent unsafe sharing of resources, something that
Go‚Äôs runtime cannot enforce. Rust‚Äôs async ecosystem, using
<code>async</code>/<code>await</code> and tools like Tokio, allows for
excellent asynchronous programming without the pitfalls of traditional
thread-based concurrency models.</p>
<h3 id="4-tooling-that-actually-works"
id="4-tooling-that-actually-works">4. Tooling That Actually
Works <a href="#4-tooling-that-actually-works" class="anchor-link">üîó</a></h3>
<p>C‚Äôs build tooling is archaic, Go‚Äôs module system is still a mess
(<code>GOPATH</code> was awful, and modules are only marginally better),
but Rust? Cargo just works. Dependencies, versioning,
cross-compilation‚Äîit‚Äôs all built-in, and I don‚Äôt have to waste time
wrestling with third-party package managers or Makefiles. Plus, tools
like clippy, rustfmt, and cargo bench integrate seamlessly. Cargo
workspaces make it easy to manage multi-crate projects, allowing for
better organization and dependency management. Honestly, it‚Äôs impeccable
overall.</p>
<h2 id="considering-zig" id="considering-zig">Considering
Zig <a href="#considering-zig" class="anchor-link">üîó</a></h2>
<p>One thing worth nothing about C is that I <em>enjoy</em> writing it.
The design of the language, unlike C++, is simple and it‚Äôs <em>fun</em>
to write. I find Rust fun too, but sometimes type errors get on my
nerves because I appear to get caught by the most basic ones that I
<em>probably</em> wouldn‚Äôt encounter on C. And while Rust has largely
taken over my system-level programming needs, I have been keeping an eye
on Zig. Zig‚Äôs simplicity, lack of hidden control flow, and compile-time
execution capabilities make it an interesting alternative to both C and
Rust in certain contexts. Though I find it still a bit immature to
really ‚Äúswitch‚Äù to as my primary language. For now Rust will do, but I
still feel compelled to mention what Zig does well.</p>
<p>Some of Zig‚Äôs strengths include:</p>
<ul>
<li><strong>Manual memory management without footguns</strong> ‚Äì Unlike
C, Zig provides safer manual memory management patterns.</li>
<li><strong>Better C interoperability than Rust</strong> ‚Äì While Rust
has <code>bindgen</code> and <code>cbindgen</code>, Zig is designed from
the ground up to interface smoothly with C code.</li>
<li><strong>No hidden control flow</strong> ‚Äì No automatic panics,
exceptions, or surprises in the compiled output.</li>
</ul>
<p>I‚Äôm not replacing Rust with Zig anytime soon, but for cases where
Rust‚Äôs safety mechanisms feel like overkill, or where I need tighter
control over binary size and startup time, Zig looks promising. It‚Äôs too
early to say if it‚Äôll take a permanent place in my workflow, but I am
keeping an eye on it.</p>
<h2 id="why-c-still-has-a-place" id="why-c-still-has-a-place">Why C
Still Has a
Place <a href="#why-c-still-has-a-place" class="anchor-link">üîó</a></h2>
<p>Despite moving to Rust, C continues to hold a vital place in my
workflow. Its low-level access and direct mapping to hardware make it
indispensable for performance-critical tasks, interfacing with legacy
systems, or working on projects where every cycle counts. However, there
are areas where C leaves a lot to be desired.</p>
<ul>
<li>Build Systems Are a Mess ‚Äì Make, CMake, Autotools‚Äînone of them are
great, and package management is nonexistent.</li>
<li>Undefined Behavior Everywhere ‚Äì The sheer number of ways you can
shoot yourself in the foot in C is staggering. Buffer overflows,
use-after-free, integer overflows‚ÄîRust eliminates these entirely.</li>
<li>Lack of Modern Language Features ‚Äì No generics, no proper modules,
and macros are still the hacky preprocessor-based mess they have always
been.</li>
</ul>
<p>That said, C isn‚Äôt going anywhere. There‚Äôs too much legacy code, too
many embedded systems, and too many low-level performance demands for it
to disappear. If you want to write kernels, firmware, or low-level
graphics code, you still want C, though you don‚Äôt necessarily
<em>need</em> it. I find Rust‚Äôs bootstrappability to be a drawback, but
that‚Äôs for another post.</p>
<h2 id="go-has-replaced-python-for-web-and-scripting"
id="go-has-replaced-python-for-web-and-scripting">Go Has Replaced Python
for Web and
Scripting <a href="#go-has-replaced-python-for-web-and-scripting" class="anchor-link">üîó</a></h2>
<p>For quick scripting, Go has taken over Python‚Äôs role in my workflow,
especially for anything web-related. Python‚Äôs performance is atrocious,
and while Flask is easy to use, it crumbles under load. Go, on the other
hand, compiles to a single binary, has a solid HTTP stack, and doesn‚Äôt
require setting up a virtual environment just to run a script. The
<code>net/http</code> package provides a robust and easy-to-use HTTP
server and client, while frameworks like <code>gorilla/mux</code> offer
more advanced routing capabilities.</p>
<p>That‚Äôs not to say Go is perfect‚Äîits standard library is missing some
utilities that Python has had forever‚Äîbut for quick-and-dirty web tools,
it‚Äôs become my go-to and I‚Äôll take Go over Python any day. Though the
bar is low, and Go is barely doing anything to remain above it.</p>
<h2 id="final-thoughts" id="final-thoughts">Final
Thoughts <a href="#final-thoughts" class="anchor-link">üîó</a></h2>
<p>Transitioning to Rust did not mean discarding Golang or C entirely.
Each language serves its purpose:</p>
<ul>
<li><strong>Rust</strong> now leads my efforts in building safe,
efficient, and modern systems.</li>
<li><strong>C</strong> continues to be my go-to for low-level
programming tasks, where control over hardware is paramount, despite its
antiquated tooling. I usually try to work in single files and avoid
libraries when I‚Äôm working with C, which is a good learning experience
on how to build stuff but still annoying.</li>
<li><strong>Golang</strong> still finds its place in projects where
rapid development and simplicity are necessary, though its limitations
have driven my current focus away.</li>
<li><strong>Zig</strong> is an emerging contender that I may use for
certain low-level applications where Rust or C might otherwise be
considered.</li>
</ul>
<p>Long thing short, Rust isn‚Äôt for everything, and neither is Go or C.
Each language has its niche, and the trick is knowing when to use what.
Rust replaced Go for me in performance-sensitive areas, but I still keep
Go around for web scripts and C for low-level work. Zig? Maybe it‚Äôll
earn a place too. Time will tell.</p> 
    </main>
    <footer>
      <div class="footer-divider"></div>
      <p>&copy; <span id="copyright"></span> NotAShelf</p>
      <div class="footer-icons">
        <a href="https://github.com/notashelf">
          <i class="lni lni-github" title="GitHub"></i>
        </a>
      </div>
    </footer>
    <script defer src="/static/scripts/copyright.js"</script>
    <script
        defer
      data-domain="blog.notashelf.dev"
      src="https://pl.notashelf.dev/js/script.file-downloads.hash.outbound-links.tagged-events.js"
    ></script>
    <script>
      window.plausible =
        window.plausible ||
        function () {
          (window.plausible.q = window.plausible.q || []).push(arguments);
        };
    </script>

        </body>
</html>
