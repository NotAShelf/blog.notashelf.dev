<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="generator" content="pandoc" />
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1.0, user-scalable=yes"
		/>
		   		<meta name="description" content="Notes on Nix, Linux and every other pie I put a finger in" />
				<title>Posts - Just Stop</title>
		<style>
			code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
/* The extra [class] is a hack that increases specificity enough to
   override a similar rule in reveal.js */
ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
  font-size: inherit;
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    background-color: #232629;
    color: #7a7c7d;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #7a7c7d;  padding-left: 4px; }
div.sourceCode
  { color: #cfcfc2;  }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span { color: #cfcfc2; } /* Normal */
code span.al { color: #95da4c; background-color: #4d1f24; font-weight: bold; } /* Alert */
code span.an { color: #3f8058; } /* Annotation */
code span.at { color: #2980b9; } /* Attribute */
code span.bn { color: #f67400; } /* BaseN */
code span.bu { color: #7f8c8d; } /* BuiltIn */
code span.cf { color: #fdbc4b; font-weight: bold; } /* ControlFlow */
code span.ch { color: #3daee9; } /* Char */
code span.cn { color: #27aeae; font-weight: bold; } /* Constant */
code span.co { color: #7a7c7d; } /* Comment */
code span.cv { color: #7f8c8d; } /* CommentVar */
code span.do { color: #a43340; } /* Documentation */
code span.dt { color: #2980b9; } /* DataType */
code span.dv { color: #f67400; } /* DecVal */
code span.er { color: #da4453; text-decoration: underline; } /* Error */
code span.ex { color: #0099ff; font-weight: bold; } /* Extension */
code span.fl { color: #f67400; } /* Float */
code span.fu { color: #8e44ad; } /* Function */
code span.im { color: #27ae60; } /* Import */
code span.in { color: #c45b00; } /* Information */
code span.kw { color: #cfcfc2; font-weight: bold; } /* Keyword */
code span.op { color: #cfcfc2; } /* Operator */
code span.ot { color: #27ae60; } /* Other */
code span.pp { color: #27ae60; } /* Preprocessor */
code span.re { color: #2980b9; background-color: #153042; } /* RegionMarker */
code span.sc { color: #3daee9; } /* SpecialChar */
code span.ss { color: #da4453; } /* SpecialString */
code span.st { color: #f44f4f; } /* String */
code span.va { color: #27aeae; } /* Variable */
code span.vs { color: #da4453; } /* VerbatimString */
code span.wa { color: #da4453; } /* Warning */
		</style>
				<link rel="stylesheet" href="/home/runner/work/blog.notashelf.dev/blog.notashelf.dev/templates/style.css" />
				<!-- Begin Lineicons import -->
		<link
			rel="stylesheet"
			href="https://cdn.lineicons.com/4.0/lineicons.css"
		/>
		<!-- End Lineicons import-->
		<link rel="stylesheet" href="/style.css" />
	</head>
	<body>
		<header>
			<nav class="primary-buttons">
				<ul>
					<li><a class="nav-button" href="/">Index</a></li>
				</ul>
			</nav>
			<nav class="secondary-buttons">
				<ul>
					<li>
						<div class="dropdown">
							<button class="nav-button">Posts</button>
							<div
								class="dropdown-content"
								id="dropdown-content"
							></div>
						</div>
						<a class="nav-button" href="/pages/about.html">
							About
						</a>
						<a class="nav-button" href="/pages/privacy.html">
							Privacy
						</a>
					</li>
				</ul>
			</nav>
		</header>

		<main>
						<nav id="TOC" role="doc-toc">
				 <ul>
<li><a href="#please-just-stop" id="toc-please-just-stop">Please Just
stop</a>
<ul>
<li><a href="#what-is-just" id="toc-what-is-just">What is Just?</a></li>
<li><a href="#please-just-stop-1" id="toc-please-just-stop-1">Please,
just stop</a>
<ul>
<li><a href="#just-do-better" id="toc-just-do-better">Just do
better!</a></li>
<li><a href="#in-the-wild" id="toc-in-the-wild">In the wild</a></li>
</ul></li>
<li><a href="#conclusion" id="toc-conclusion">Conclusion</a>
<ul>
<li><a href="#what-to-do-instead" id="toc-what-to-do-instead">What to do
instead?</a></li>
</ul></li>
</ul></li>
</ul>
			</nav>
			 <h1 id="please-just-stop">Please Just stop</h1>
<h2 id="what-is-just">What is Just?</h2>
<p><a href="https://github.com/casey/just">Just</a> is a fast and
powerful command runner, built with Rust. It is fast, simple and
available <a
href="https://github.com/casey/just?tab=readme-ov-file#packages">almost
everywhere</a> with top-notch editor and CI integration.</p>
<p>So why do I have beef with Just?</p>
<h2 id="please-just-stop-1">Please, just stop</h2>
<p>I actually have no beef with Just, I have briefly read the project
page and tested it somewhat extensively on my own machine. The tool
itself is impressive, however, it is also redundant when tools like Nix
exist!</p>
<h3 id="just-do-better">Just do better!</h3>
<p>If you have previously read my blog, you probably know that I use the
<a href="https://nixos.org/explore/">Nix package manager</a><a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> on a daily basis, and NixOS as my
primary system.</p>
<blockquote>
<p>For those who have no idea what Nix is, it's a package manager and a
build tool that supports declarative, reproducible and reliable builds
&amp; deployments anywhere. I invite you to read more about it <a
href="https://nix.dev/#what-can-you-do-with-nix">here</a></p>
</blockquote>
<p>Nix does not exactly compare with Just, as Just is a command runner
but it provides its full functionality in Nix devShells. You can use
devShells not only to declaratively install your development packages
inside specific project directories (which is built upon further by
projects like <a href="https://direnv.net/">direnv</a>) but also write
fully fledged scripts and helpers in Bash, Python, Ruby or whatever
interpreted or compiled language you want to make them available in your
projects.</p>
<p>A common counter-argument to this is that they don't want to force
people to install yet another tool, however, Just <em>is</em> that "yet
another tool" you said you don't want people to install. If I am
installing something, I <em>might as well opt in for the extensible
one</em>.</p>
<h3 id="in-the-wild">In the wild</h3>
<p>My intention is neither to gatekeep Just, nor to advertise Nix for
new people. What I want to get at is that if you have Nix installed, you
<strong>do not need Just</strong>. Simple as that.</p>
<p>While browsing GitHub, I have seen <em>countless</em> Nix projects
that recommend using Just to run some simple commands (such as
<code>nix build</code> in large projects, or <code>nixos-rebuild</code>
in system configurations). Please just stop.</p>
<p>When given a powerful tool (which <em>is</em> installed on your
system) you should be utilizing that tool to its fullest extent,
<em>not</em> introduce a completely irrelevant tool that is inferior to
what you have in every way.</p>
<p>If you are using NixOS and want to provide bootstrapping commands to
rebuild your system, <strong>use devShells</strong>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>And this has been my rant. Please understand that my aim is not to
discourage you from using Just, but to encourage you to use the correct
tool on your belt.</p>
<p>If you use NixOS but have zero clue how to use devShells, then I
implore you to reconsider your choice of distro. NixOS is a powerful
tool that needs, nay, <em>demands</em> your attention and
understanding.</p>
<p>If you do not intend to use the blessings provided by Nix to you,
then you probably do not need to suffer the many side effects of Nix
(such as but not limited to <a href="https://github.com/gerg-l">severe
hairloss</a>).</p>
<h3 id="what-to-do-instead">What to do instead?</h3>
<p>For my curious but equally lazy readers, here is how you may use a
devShell.</p>
<p>Start by creating a <code>shell.nix</code> that contains your shell
environment.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="va">pkgs</span> <span class="op">?</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{}</span> <span class="op">}</span>:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  pkgs.mkShell <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># nativeBuildInputs is usually what you want -- tools you need to run</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">nativeBuildInputs</span> <span class="op">=</span> <span class="kw">with</span> pkgs.buildPackages<span class="op">;</span> <span class="op">[</span> <span class="op">];</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This setup implies you are using channels, but similar instructions
will apply on flakes. Regardless, acquire your development packages from
nixpkgs and put them in your shell's <code>nativeBuildInputs</code>. If
you are trying to put, e.g., a Python script available in <a
href="https://github.com/NixOS/nixpkgs">nixpkgs</a>, simply place it in
<code>nativeBuıldInputs</code>. If you want your own shell script to be
in the shell, then you can write your script as follows:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="va">pkgs</span> <span class="op">?</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{}</span> <span class="op">}</span>:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  pkgs.mkShell <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">nativeBuildInputs</span> <span class="op">=</span> <span class="kw">with</span> pkgs.buildPackages<span class="op">;</span> <span class="op">[</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">(</span>pkgs.writeShellScriptBin <span class="st">&quot;my-builder-script&quot;</span> <span class="st">&#39;&#39;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="st">        echo &quot;hello world&quot;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="st">      &#39;&#39;</span><span class="op">)</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">];</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This will place <code>my-builder-script</code> in your
<code>PATH</code> after you enter the shell with e.g.
<code>nix develop</code> or automagically if you use something like
direnv. Obviously the contents can be whatever you want, and you can
write a script as complex as you need. Aside from being a simple runner
that did what Just does, you will also have a fully reproducible script
that fulfils your needs without installing an additional tool thats sole
purpose is to run commands.</p>
<p>If you use Just to run your rebuild scripts, you can easily package
your rebuild scripts with Nix using <code>writeShellScript*</code> from
trivial builders collection and completely ditch Just. Remember that
someone observing your NixOS configuration is less likely to use Just,
and more likely to use Nix. Choose the appropriate tool for the job,
lest you over or underprepare.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Nix is actually not a package manager. It has been
called that was to make it more approachable for the casual users, but
it is actually a build tool. Or better yet, it is <strong>lambda
calculus on files</strong>. I feel the need to clarify, because package
management is <em>only one</em> of Nix's features. Whereas running
commands is Just's only function.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section> 
		</main>
		<footer>
			<div class="footer-divider"></div>
			<p>&copy; <span id="copyright"></span> NotAShelf</p>
			<div class="footer-icons">
				<a href="https://github.com/notashelf">
					<i class="lni lni-github-original" title="GitHub"></i>
				</a>
			</div>
		</footer>
		<script>
			// Update the copyright text
			const currentYear = new Date().getFullYear();
			const copyrightYear =
				currentYear !== 2024 ? "2024 - " + currentYear : "2024";

			document.getElementById("copyright").textContent = copyrightYear;

			// Dropdown post listing
			function fetchPosts() {
				fetch("/posts/posts.json")
					.then((response) => response.json())
					.then((data) => {
						const dropdownContent =
							document.getElementById("dropdown-content");
						data.posts.forEach((post) => {
							const postLink = document.createElement("a");
							postLink.textContent = post.title;
							// we could use posts.url here, instead of posts.path
							// but it messes with local serving, which prefers `/`
							// to the actual URL, as it would point to the live site
							// by path
							postLink.href = post.path;
							dropdownContent.appendChild(postLink);
						});
					})
					.catch((error) =>
						console.error("Error fetching posts:", error),
					);
			}

			document.addEventListener("DOMContentLoaded", () => {
				fetchPosts();
			});
		</script>
	</body>
</html>
